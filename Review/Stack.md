
https://wdxtub.com/interview/Problem/0014520597235248.html

#堆棧和佇列

## 解題策略

* 考慮到棧具有LIFO的特性，那麽與之匹配地，最大值追蹤方式也需要具有相同特性：  
不妨用另一個棧追蹤最大值。

* 遍歷子樹的過程是一個自上而下結構：從頂層出發，逐漸向下擴散。  
所以考慮遞歸或者棧。 

* 從最基本的情況出發，根據題意推倒整個計算流程。這樣做的好處是：
    1. 確保自己正確地理解了題目 
    2. 從簡單的情況出發，找找解題思路。該方法特別適用於遞歸，動態編程等題目類型。
    
* 由於棧具有LIFO的特性，如需實現任何特定順序的讀取操作，往往可以借助兩個棧互相“傾倒”來實現特定順序。事實上，在很多情況下，棧並不是實現這種讀取順序的最佳數據結構。但作為面試問題，往往面試官會很明確的說明用棧實現。  
此時，我們就應該立刻想到利用另一個棧作為輔助。

* 有一類問題有這樣的特性：當前節點的解依賴後驅節點。  
也就是說，對於某個當前節點，如果不能獲知後驅節點，就無法得到有意義的解。  
這類問題可以通過棧(或等同於棧的若幹個臨時變量)解決：  
先將當前節點入棧，然後看其後繼節點的值，直到其依賴的所有節點都完備時，  
再從棧中彈出該節點求解。某些時候，甚至需要反覆這個過程：  
將當前節點的計算結果再次入棧，直到其依賴的後繼節點完備。  

* 所謂的自上而下(Top-Down)結構，從邏輯理解的角度來看，實際上就是一種樹形結構，  
從頂層出發，逐漸向下擴散，例如二叉樹的遍歷問題。   
在實際運算的時候，我們先解決子問題，再利用子問題的結果解決當前問題。  
從算法角度而言，就是利用遞歸。用遞歸解決自上而下結構的問題。  

* 由於棧的LIFO特性，可以利用棧數據結構消除遞歸。  
遞歸通常用函數調用自身實現，在調用的時候系統會分配額外的空間，  
並且需要用棧指針記錄函數返回的位置，故額外開銷(overhead)比較大。  
但在實際工作或面試中，往往用棧或者用遞歸的區別不大，按照自己擅長的方式做就可以。  
在使用棧的時候，每個子問題應當被看成是同樣類型的對象(object)，  
將該對象按照自上而下“的方向入棧。然後通過while循環，  
調用棧的pop()函數彈出棧頂元素並訪問，直至棧清空。  
這樣，後入棧的子問題會優先被彈出，相當於實現了遞歸。  

## 棧
棧(stack)是一種數據結構，可以實現後進先出(Last in first out, LIFO)。  
通常情況下，我們可以用棧作為輔助，實現深度優先算法(Depth first search, DFS)，  
或者將遞歸轉為while循環。

事實上，遞歸本身就是相當於把函數本身一層一層地加到操作系統的內存棧上，  
所以利用棧數據結構去實現遞歸也是非常自然的：  
入棧操作相當於遞歸調用自身，出棧操作相當於遞歸返回。  
入棧操作的對象相當於需要被解決的問題，出棧對象相當於已經解決的子問題，  
通過共享的狀態變量或返回值把子問題的結果傳遞出來。

最基本的棧至少包括入棧(push)和出棧(pop)，  
前者將一個元素放入棧內，後者將最後放入棧的元素彈出。  

## 佇列
與棧對稱，佇列(Queue)幫助實現先進先出(First in first out, FIFO)，  
我們可以用Queue作為輔助，實現廣度優先算法(Breadth first search, BFS)。  
佇列還可以作為buffer，構建一個生產者－消費者模型：  
生產者把新的元素加到隊尾，消費者從隊頭讀取元素。  
在有兩個線程同時讀取同一個佇列時，需要考慮同步(synchronization)

事實上，棧 與佇列可以視作封裝好的鏈表，只是限制了訪問和插入的自由。  
因此適用棧或佇列的情境，也可以考慮使用更為強大的鏈表。  
  

***  
  
### [00388.Longest_Absolute_File_Path](../../SourceCode/Python/Problem/00388.Longest_Absolute_File_Path.py) Level: Medium Tags: [Stack]
    
  
思路: 這是Google的OA題目 (Online Assessment) 
題目出現頻率之高，要考google的人建議別錯過這題  
給你一串用換行還有tab分隔的目錄路徑和檔案名稱  
找出最長的路徑名  
Google的原題是找出圖片文件的路徑和，只有些許變化  
  
核心思路是準備一個Stack，存放每個目錄或檔案的長度和所在目錄深度  
目錄和檔案可以用\n分隔開，深度可以用tab的數量來決定  
從左到右掃描被分隔開的檔案/目錄名  
確定深度後和Stack頂端的元素比較其深度  
如果Stack內元素的深度較大的話  
就把頂部元素彈出來，因為這不是當前目錄/檔名的目標深度  
一直彈到頂部元素的深度小於當前目錄/檔名的深度為止  
```python
currDepth = p.count('\t')
depth, length = stack[-1]
while depth >= currDepth:
    totalLength -= length
    stack.pop()
    depth, length = stack[-1]
```
剩下要注意的地方就是最終判斷合法路徑是由"檔案名稱"決定的而不是目錄  
所以判斷目前的分隔字串是檔案名稱才需要考慮把它納入最終解  
```python
if p.count('.'):
    ans = max(ans, totalLength + currLength)
```
    
  
   
***  