  
https://wdxtub.com/interview/Problem/0014520597062776.html

# 動態規劃
動態規劃(Dynamic Programming, DP)是算法類問題中的難點所在。  
算法的核心在於找到狀態轉移方程，即如何通過子問題解決原問題。  
在“The Rules”部分，我們先介紹遞規和DP的普適特性；  
再通過“模式識別”，從題目的關鍵字出發，  
判斷什麽樣的題目適合用遞歸和DP，並且總結算法模版  
  
## 解題策略  
當求解的問題滿足以下兩個條件時， 就應該使用動態規劃：　　
1. 主問題的答案包含了可分解的子問題答案  
  （也就是說，問題可以被遞歸的思想求解）
2. 遞歸求解時，很多子問題的答案會被多次重覆利用  
  
動態規劃的本質思想就是遞歸  
但如果直接應用遞歸方法，子問題的答案會被重覆計算產生浪費    
同時遞歸更加耗費堆疊記憶體    
所以通常用一個二維矩陣（表格）來表示不同子問題的答案  
以實現更加高效的求解。  
  
  
  
  
## 用動態規劃(自底向上)解決收斂結構問題
具有強收斂性/Aggregate屬性的問題  
(承前所述，是指關於特解，或最值，或總和，或數量的問題)，  
都可以用整數坐標映射所有節點，且當前節點的解只依賴於前驅節點(無論是順序還是倒序)。  
那麽，這類問題往往可以用DP解決。  
解決的關鍵是建立子問題的解之間的遞推關係：
```
f(n) = G[f(n-1), f(n-2), … , f(1)] 或
f(i, j) = G[f(i-1, j-1), f(i, j -1), f(i-1,j)]
```
其中G[ ]表示子問題到原問題的映射關係，例如對於斐波那契數列，有遞推式：
```
f(n) = G[f(n-1), f(n-2)] = f(n-1) + f(n-2)
```
解決這類問題的時候，可以把上述遞推關係寫在手邊，這樣做非常有利於理清算法實現的思路。  
實際實現算法時，往往以問題的一端為循環開端，另一端為循環終止條件，將當前節點的解  
(或往往是，以當前節點為末節點的問題的解，抑或是以當前兩個坐標為輸入的問題的解)  
用DP table(即數組)記錄下來  
(如果當前節點只由之前緊接的若幹個節點決定，那麽用若干個變數也夠了)，  
數組的下標即為子問題的輸入變數，也就是遞推關係中的函式參數，  
只是把f(i,j)表示成array[i][j]而已。

如果問題除了要計算動歸終點的數值以外，還需要記錄具體的到達路徑，  
則可記錄每個節點的前驅節點```(prev[n])```或前驅路徑```(vector<vector<int>> prev)```，  
然後用終點出發通過backtracking處理成path。  
這時候記錄的前驅們都是經過了DP的剪枝，每一條路徑都是符合條件的正確路徑。  

注意，如果出現類似於“所有解”，“所有路徑”等關鍵詞，  
則用自上而下方法更為直接。之後我們也會給出例子。

## 最長子序列類型的問題
對於“最長子序列”問題(即有限空間內，滿足一定條件的最長順序子序列)，  
本身具有很強的聚合性，可以以如下方式解答：  
用DP Table來記錄以當前節點為末節點的序列的解  
(至少固定問題的一端，因此不是以“當前節點或之前節點”為末節點)的解，  
並根據遞推關係，由問題空間的起點到達問題空間的終點。

## 用Memorization (Top-Down)解決收斂結構問題
Memorization是自頂向下形式的動態規劃，並且受到的制約更少，  
自然也可以用來解決前述的問題(但空間上可能效率不及自底向上形式的DP)。

Memorization的核心在於，在原有遞歸框架下，存儲子問題的計算結果，  
在重覆計算子問題時返回已經計算的值。

值得注意的是，這裏所謂的“重覆計算子問題”，在自頂向下結構下必須與前驅節點無關，  
因為子問題並不知道原問題是如何到達當前節點的。  
舉例來說，求二叉樹從根節點到葉節點的權值最大路徑，  
對於當前節點到葉節點的路徑與之前如何到達當前節點沒有關係，  
只要計算當前節點到葉節點的路徑，就一定是重覆的計算，可以直接返回結果。  
作為反例，在一個字母矩陣當中尋找詞典中的單詞，當前路徑能否構成單詞，  
不僅與之後走的過程有關，也與之前的過程有關。  
因此，從當前節點出發，哪怕走過相同的路徑，也不能看成是重覆計算的子問題。  
在回溯部分我們會進一步講解。

## 用回溯法( 自上而下 )解決發散結構問題
對於發散性問題(例如“所有組合”，“全部解”)，  
可以選取其問題空間“收斂”的一端作為起點，沿著節點發散的方向  
(或者說，當前節點的多種選擇)進行遞歸，直到

    1. 當前節點“不合法” 或
    2. 當前節點發散方向搜索完畢，才會return
舉例來說，考慮樹的遍歷：  
根節點方向就是“收斂”的一端，節點發散的方向就是子節點。  
對於某個樹的節點，其孩子就是當前決策的多種選擇。  
當達到葉節點是，其孩子為NULL，即達到“不合法”的邊界條件。  
回溯法的核心在於選擇哪些方向/決策，才是最合理，不重覆的。  
所謂“剪枝”(pruning)，就是指：  
只選擇盡可能少的、可能到達“合法條件”的方向，而不是搜索當前節點的所有發散方向。  
這樣，可能將冪指數級的覆雜度降低到階乘級。

值得注意的是，invalid前的最末節點未必意味著合法  
(不是所有的問題走通就算滿足條件)，  
合法的節點也未必代表不需要繼續走下去  
(比如尋找到一個單詞之後，繼續走下去可能能找到以這個單詞為前綴的另一個單詞)。  
因此我們強烈推薦將invalid的判定與合法條件的判定總是分開，  
即使在某些題目中它們是一致的。  
當然，如果經過充分剪枝之後，所有搜索只會沿著“正確”的方向行進，  
那麽當前節點“不合法”往往也就意味著合法條件。

如果需要記錄決策的路徑，可以用一個List沿著搜索的方向記錄，  
在滿足合法條件時記錄當前path(通常是將path存入List)。

注意，我們傳入的path是引用形式，屬於全局變數。  
Backtracking(回溯)本身隱含的含義是，在訪問完這個節點返回時，  
需要恢覆原本的狀態(即回到該節點)，以訪問其他路徑。具體實現時，意味著需要:

    1.在return前，刪除path中的當前節點。
    2.如果搜索的方向有出現環路的可能，
    那麽可以使用一個存放Bool的List來記錄該節點是否已被使用，在訪問時以及return前維護。
如果以傳值形式傳入path，由於path成了局部變數，故在某些情況下不需要顯式回溯，  
相當於把狀態覆制給了子問題。可能有人覺得這樣做比較直觀，但其缺點是需要額外的空間。

回溯法的典型模板如下所示：
```
void backtracking( P node, vector<P> &path, vector<vector<P> >&paths ){
        if(!node )  // invalid node
            return;

        path.push_back(node);

        bool success =  ;  // condition for success
        if( success )  
            paths.push_back( vector<P>(path.begin(),path.end()) ); 
            // don't return here
        
        for( P next: all directions )
            backtracking( next, path, paths );
        path.pop_back();
        return;
}
```
## 用Divide and Conquer 解決獨立子問題
如果能將問題由幾個孤立但類似的部分組成，則可以優先選擇使用D&C策略：  
將問題分割解決，再合並結果。  
特別地，如果期望將問題的覆雜度由O(n)進一步降低到O(logn)，  
一般總是可以聯想到使用D&C策略，將問題分割而治。

### 從子問題得到最終解
遞歸和動態規劃能解決的問題都有一個特性：  
原問題(problem)可以分解成若幹個子問題(sub-problem)，  
只有先解決了子問題才能進一步解決原問題。  
子問題的解決方式形式上與原問題一致。  
從題目描述來看，可以提示我們嘗試用遞歸、DP解決的關鍵詞有：  
* compute nth element (value, sum, max, etc.) 
* return all the paths
* return all the combinations
* return all the solutions…

既然動規與遞歸都能解決相同類型的問題，那麽DP和遞歸有什麽不同？  
最大的區別在於，DP存儲子問題的結果，當子問題已經被計算過，直接返回結果。  
因此，當需要重覆計算子問題時，DP的時間效率高很多，但需要額外的空間。

特別地，具有聚合屬性的問題(Aggregate)，  
例如在所有組合中尋找符合特定條件的特解  
(比如二叉樹求一條從根節點到葉節點和為定值的路徑，或第n個元素)，  
或最優解(包括最值)，或總和，或數量的問題  
(其實看一下SQL裏的聚合函式(aggregate function)就明白了)。  
因為這些問題它們只需要一個聚合的或者特殊的結果，而不是所有滿足條件的集合，  
所以它們具有很強的收斂性質。這類問題往往也可以用DP來解決。

我們節將問題處理的每一個最小的元素/步驟，稱為節點，  
就好比一維/二維/三維數組中的一個element，或者每一次遞歸中獨立解決的那個元操作。  
我們把節點空間“兩端收斂”的問題，歸結為收斂結構；  
將節點空間“發散”的問題，歸結為發散結構。  
形象地說，收斂問題是由若幹個子問題共同決定當前狀態，即狀態的總數逐漸“收斂”，  
例如斐波那契數列問題(前兩個節點決定當前節點)；  
發散問題是當前狀態會衍生出多個下一狀態，例如遍歷已知根節點的二叉樹  
(下一層的狀態以指數形式增加)。抽象地說，能夠在多項式時間內解決的問題，  
是收斂問題(P類問題)，不能在多項式內解決的問題(如階乘級或指數級)，  
是發散問題(NP類問題)。定義“收斂”和“發散”是為了方便本章節描述和區分這兩類問題，  
並非是公認的準則。

### 遞歸的空間與時間成本
對系統層面上說，操作系統是利用函式棧來實現遞歸，每次操作可視為棧裏的一個對象。  
遞歸的時間成本隨遞歸深度n(單條路徑中遞歸調用的次數)成指數增長；  
空間覆雜度為O(n)。

### 自底向上與自頂向下
從子問題解決原問題, 無非是兩種方法，  
自底向上(Bottom-Up)與自頂向下(Top-Down)，  
形式上前者對應iteration，利用循環將結果存在數組裏，從數組起始位置向後計算；  
後者對應recursion，即利用函式調用自身實現，如果不存儲上一個狀態的解，則為遞歸，  
否則就是DP。舉個斐波那契數列(0,1,1,2,3,5…)的例子：

1) 自底向上
```python
array = [0] * n
array[1] = 1
for i in xrange(2, n):
    array[i] = array[i-1] + array[i-2]
```

這裏，為了說明方法，采用數組存儲結果，空間覆雜度O(n)。  
事實上，額外空間可以進一步縮小到O(1)：利用幾個變數記錄之前的狀態即可。  
由於我們記錄了子問題的解，故給出的方法就是DP。  
事實上，自底向上的方式往往都是通過動態規劃實現。

2) 自頂向下
```python
def Fibonacci(n):
    if n == 0:
        return 0
    if n == 1:
        return 1
    return Fibonacci(n-1) + Fibonacci(n-2)
```

為計算Fibonacci的第n個元素，我們先自頂向下地計算子問題：  
第n-1個元素和第n-2個元素。  
由於沒有存儲子問題的運算結果，我們給出的方法是遞歸。  
然而，Fibonacci(n-1)與Fibonacci(n-2)包含很多重覆的子問題，所以DP效率更高。  
如果用一個全局數組，將子問題的解存儲到數組的對應位置，  
在重覆計算的時候直接讀取計算結果，那麽就是DP的解法。

*我們再次強調：*  
*動態規劃的核心在於，如果在一個問題的解決方案中，子問題被重覆計算，*
*那麽就可以利用記錄中間結果，達到用空間換取時間的目的。*

以下如不額外說明，動態規劃特指叠代形式的自底向上的動態規劃，  
並將自頂向下，遞歸形式，在遞歸過程中用哈希表記錄中間計算結果的DP，  
稱作Memorization。

Memorization的一般形式是: 建立以input為鍵，以output為value的哈希表：
```
T func(N node, HashTable<N, T>& cache) {
    If (cache.contains(node)) {
        return cache.get(node);
    }
    …
    T sub_res = func(next_node, cache);
…
    T res = G( sub_res … );  //當前子問題的解，依賴於更小的子問題(s)
    cache.set(node, res);
    return res;
}
```
從解決問題的角度來說，用自底向上的DP，固然通常可以節省遞歸本身的空間開銷，  
但有很多缺點和局限：較難理解，邊界條件較難處理，  
只適用於問題的節點空間是離散的整數空間，必須一步步鄰接、連續地計算  
(無論是不是每一個節點的結果都會被用到)。  
而Memorization，則靈活得多：可以從遞歸形式輕易修改得到，  
也更符合普遍的思維過程，並且沒有上面說的這些局限，子問題只有在被需要的時候才會被計算。  
尤其是在某些情況下，不僅需要aggregate的結果，還需要獲得achieve這個結果的路徑，  
這時候就算用自底向上的DP，也需要記錄prev節點，最後需要遞歸回溯得到路徑，  
那麽節省遞歸空間開銷的優勢，也蕩然無存了。

盡管有上述局限, 自底向上的DP，仍然可以作為很好的思維和編程訓練，  
熟練之後寫法也很簡潔精妙。

## 算法策略
以下回顧一些利用到DP思想的經典算法策略：

* 分而治之(Divide and Conquer)
    * 這裏只談狹義的D&C，即將問題分成幾個部分，每一部分相互獨立，互不重疊，  
    假定每個部分都可以得到解決來進行遞歸調用，合並每一部分的結果。
    * 例如Merge Sort， Quick Sort (Merge Sort的divide容易，  
    但Conquer/Merge複雜，Quick Sort的divide複雜，但Conquer/Merge容易)
* 動態規劃(Dynamic Programming)
    * 盡可能不重覆計算每個子問題，而是將計算結果存儲下來，以確定後驅問題的解。
    * 與貪心算法的區別是，會記錄下所有可能通向全局最優解的局部解，  
        以便在計算後驅問題時綜合考慮多個前驅問題的解。
* 貪婪算法(Greedy Algorithm)
    * 只做出當下最優的判斷，並且以此為基礎進行下一步計算。當前判斷最優時，不考慮對全局/未來的影響，所以所以從全局來說並不能保證總是最優。
    * 貪心算法每次更新當前的最優解。如Dijkstra算法就是貪心算法的實例之一。
* 回溯 (Backtracking)
    * 一種暴力(窮舉)的深度優先搜索法：搜索，直到節點空間的盡頭，  
    然後再返回到上次的節點，再往其他方向深度搜索。
    * 樹或圖的DFS是回溯的實例之一。
     
***

### [00010.Regular_Expression_Matching](../../SourceCode/Python/Problem/00010.Regular_Expression_Matching.py) Level: Hard Tags: [DP]
  
Time:  O(m * n)  
Space: O(m * n)  
  
思路:其實就是把正規表示式的"." 和 "*"寫出來    
十分難的一題  
和 [00044.Wildcard_Matching](../../SourceCode/Python/Problem/00044.Wildcard_Matching.py)  很像  
但兩者間有微妙的差別，具體可以見44題的思路  
不過簡單來說，這題比44題難多了  
因為本題的"*"有太多狀況要考慮了  
  
這題我們用Dynamic Programming(DP)解題  
首先我們準備一個二元的DP陣列，大小為 (s+1)*(p+1)
裏頭的元素除最左上角為True外，其餘初始值均為False    
我們用它來做DP的matching  
其中心思想是dp[sp][pp]為 s[0:sp] 和p[0:pp]是否match  
其餘的規則，我們用範例來說明，例子如下    
```
s = "xaabyc"
p = "xa*b.c"
```
以上面的例子來說，我們需要一個7*7的DP陣列 
第一行和第一列代表沒有任何字元或沒有任何pattern  
所以 "" 一定match空pattern "" 
  
|s\p|   | x | a | * | b | . | c |
|---|---|---|---|---|---|---|---|
|   | T |   |   |   |   |   |   |
| x |   |   |   |   |   |   |   |
| a |   |   |   |   |   |   |   |
| a |   |   |   |   |   |   |   |
| b |   |   |   |   |   |   |   |
| y |   |   |   |   |   |   |   |
| c |   |   |   |   |   |   |   |
    
    
在開始match traversal之前，我們先檢查一個特殊的scenario  
也就是第一行，這裡先用另一個例子說明
```s = "", p = "c*"```
在正規表示式中，"*"代表他前面的字元有可能出現多個，也有可能不出現  
所以當p[pp]為*且為第二個字元時，他必定符合空字串    
所以他的欄位應該填上True  
而我們一開始的例子裡並沒有這種情況  
所以第一行應該都填上False　　

接著我們正式開始填DP陣列  
以正規表示式來說，我們可以找到下面的規則  

1. 如果當前p的欄位是"*"的話，分成以下三種情況  
a) 考慮 "xa" match "xa*"的場合:  
p往前退一個時，"xa"一樣能match "xa"  
所以只要dp[sp][pp-1]的欄位為True，當前欄位就為True  
  
b) 考慮 "x" match "xa*" 的場合:
p往前退兩個時，"x"一樣能match "x"  
所以只要dp[sp][pp-2]的欄位為True，當前欄位就為True  
  
c) 考慮 "xaa" match "xa*" 的場合:  
只要s退一步，就能走到和上面a)一樣的 "xa" match "xa*"  
這時我們除了要確認之前match的結果 (dp[sp-1][pp])是否為True外  
還要確認s和p的前一個字元是否相同  (s[sp-1] == p[pp-2])  
或者p的前一個字元是否為'.' (p[pp-2] == '.')  
以"xaa" match "xa*"來說，他符合 s[sp-1] -> "a" == p[pp-2] -> a
所以 "xaa" match "xa*" 的欄位為 True

2. 如果當前p的欄位為"."的話，代表符合任意一個字元  
因此我們可以比較他的前一個比較結果 (dp[sp-1][pp-1]) 是否為True  
是的話當前欄位就為True  

3. 如果s的當前字元 (s[sp-1]) 等於當前p字元的話
那當然也是可以參考他的前一個結果 (dp[sp-1][pp-1])
  
情況2和3可以寫在一起以節省行數  
  
知道規則後我們從第二列開始填起  
注意*號的欄位可以參考前一個的True或前二個的True  
所以他為True

|s\p|   | x | a | * | b | . | c |
|---|---|---|---|---|---|---|---|
|   | T |   |   |   |   |   |   |
| x |   | T |   | T |   |   |   |
| a |   |   |   |   |   |   |   |
| a |   |   |   |   |   |   |   |
| b |   |   |   |   |   |   |   |
| y |   |   |   |   |   |   |   |
| c |   |   |   |   |   |   |   |
  
  
接著第三列  
比較令人注意的是 "xa" == "xa*"  

|s\p|   | x | a | * | b | . | c |
|---|---|---|---|---|---|---|---|
|   | T |   |   |   |   |   |   |
| x |   | T |   | T |   |   |   |
| a |   |   | T | T |   |   |   |
| a |   |   |   |   |   |   |   |
| b |   |   |   |   |   |   |   |
| y |   |   |   |   |   |   |   |
| c |   |   |   |   |   |   |   |


接著第四列  

|s\p|   | x | a | * | b | . | c |
|---|---|---|---|---|---|---|---|
|   | T |   |   |   |   |   |   |
| x |   | T |   | T |   |   |   |
| a |   |   | T | T |   |   |   |
| a |   |   |   | T |   |   |   |
| b |   |   |   |   |   |   |   |
| y |   |   |   |   |   |   |   |
| c |   |   |   |   |   |   |   |
  
  
全部填完後可得  

|s\p|   | x | a | * | b | . | c |
|---|---|---|---|---|---|---|---|
|   | T |   |   |   |   |   |   |
| x |   | T |   | T |   |   |   |
| a |   |   | T | T |   |   |   |
| a |   |   |   | T |   |   |   |
| b |   |   |   |   | T |   |   |
| y |   |   |   |   |   | T |   |
| c |   |   |   |   |   |   | T |

最右下角的欄位就是我們要的答案
這裡為True，所以 "xaabyc" macth "xa*b.c" 為True    


***
  
### [00044.Wildcard_Matching](../../SourceCode/Python/Problem/00044.Wildcard_Matching.py) Level: Hard Tags: [DP]
   
思路: 題目要求用?代表一個字元，*代表所有字元    
來比對該字串是否符合特定的pattern  
這裡有兩種解法，第一種是暴力算法，我們在這裡省略    
想看的話可以去看Hard.md  
第二種解法是動態規劃  
我們以題目給的其中一個例子來說明
```  
s = "acdcb"  
p = "a*c?b"  
```
  
首先我們宣告一個len(s)+1 x len(p)+1 的表格  
表格內的內容除了最左上角是True外，其他全為False  
如下表

|s\p|   | a | * | c | ? | b |
|---|---|---|---|---|---|---|
|   | T |   |   |   |   |   |
| a |   |   |   |   |   |   |
| c |   |   |   |   |   |   |
| d |   |   |   |   |   |   |
| c |   |   |   |   |   |   |
| b |   |   |   |   |   |   |

這是DP的表格，我們用sp和pp來iterate這個表格  
他們的初始值都是0，而dp[0][0]永遠為True  
一般情況下d[sp][pp]表示s[0:sp-1]和p[0:pp-1]是否有match    
所以我們可以不斷的參考前面的結果來得到目前的結果  

在正式填表之前，我們需要對星號做特別處理  
因為有可能p的開頭就有星號  
做法是看第一列dp[0]，如果某個元素有星號的話  
他後面的元素就會遵從這星號對應的結果  
以上表來說就是這樣  

|s\p|   | a | * | c | ? | b |
|---|---|---|---|---|---|---|
|   | T |   | F | F | F | F |
| a |   |   |   |   |   |   |
| c |   |   |   |   |   |   |
| d |   |   |   |   |   |   |
| c |   |   |   |   |   |   |
| b |   |   |   |   |   |   |

這基本上是針對第一個元素是星號程式碼  
如s = "aa", p ="*"時  
第一列都會變為True  

現在我們要正式填表了
填表格的規則如下:  

1. 如果當前p的欄位是"?"或者s[sp] match p[pp]  
那當前的欄位就可以參考前一個match的結果  
即dp[sp][pp] = dp[sp-1][pp-1]  

2. 如果當前p的欄位是"*"  
那可以直接參考他上方或他左方的結果  
其中一個是True，該欄位就能寫成True  

3. 其他情況的話保持原樣False  
  
  
我們先看sp=1的情況  
sp和pp都為1的時候，"a" match "a" 所以表格為   

|s\p|   | a | * | c | ? | b |
|---|---|---|---|---|---|---|
|   | T |   | F | F | F | F |
| a |   | T |   |   |   |   |
| c |   |   |   |   |   |   |
| d |   |   |   |   |   |   |
| c |   |   |   |   |   |   |
| b |   |   |   |   |   |   |

接著走到星號時  
"a" match "a*"所以為True
  
|s\p|   | a | * | c | ? | b |
|---|---|---|---|---|---|---|
|   | T |   | F | F | F | F |
| a |   | T | T |   |   |   |
| c |   |   |   |   |   |   |
| d |   |   |   |   |   |   |
| c |   |   |   |   |   |   |
| b |   |   |   |   |   |   |  
  
同理，第三行的元素為  

|s\p|   | a | * | c | ? | b |
|---|---|---|---|---|---|---|
|   | T |   | F | F | F | F |
| a |   | T | T |   |   |   |
| c |   |   | T | T |   |   |
| d |   |   |   |   |   |   |
| c |   |   |   |   |   |   |
| b |   |   |   |   |   |   |
  
  
中間過程省略，我們看最後一行的結果(False省略)    

|s\p|   | a | * | c | ? | b |
|---|---|---|---|---|---|---|
|   | T |   |   |   |   |   |
| a |   | T | T |   |   |   |
| c |   |   | T | T |   |   |
| d |   |   | T |   | T |   |
| c |   |   | T | T |   |   |
| b |   |   | T |   | T |   |
  
最右下角的元素便代表全部的match結果    
所以這個match的結果為False  
"acdcb" 不match "a*c?b"  
  
  
***
  
### [00123.Best_Time_to_Buy_and_Sell_Stock_III](../../SourceCode/Python/Problem/00123.Best_Time_to_Buy_and_Sell_Stock_III.py) Level: Hard Tags: [DP]
  
Time:  O(n)  
Space: O(n)  
  
思路: 是[00122.Best_Time_to_Buy_and_Sell_Stock_II](../../SourceCode/Python/Problem/00122.Best_Time_to_Buy_and_Sell_Stock_II.py)   
     和[00121.Best_Time_to_Buy_and_Sell_Stock_II](../../SourceCode/Python/Problem/00121.Best_Time_to_Buy_and_Sell_Stock.py) 的延伸  
但本題因為只能用DP解題，屬於高難度  
同樣是買低賣高，這題限制只能做兩次交易  
我們用一維的雙動態規劃來解題  
使用兩組DP陣列 DP1和DP2   
DP1代表在遍歷prices數列時，在prices[x]之前所能達到的最大利潤  
DP2代表在逆向遍歷prices數列時，在prices[x]之後所能達到的最大利潤  
則DP1[x]的利潤加上DP2[x]的利潤  
就是代表在x時間點前後的兩次交易所能達到的利潤  
所以取兩者和的最大值即為所求  
  
另一種特別的解法是  
其實我們並不需要每個時間點買賣第一第二筆股票收益的所有利潤  
我們只要知道前一個時間點買賣第一第二筆股票的最大利潤  
就能得到當前最大的最大利潤了  
我們在遍歷prices數列的時候  
使用四個變數:  
buy1: 在該價格買入第一筆股票後手裡剩的錢  
sell1: 在該價格賣出第一筆股票後手裡剩的錢  
也就是說第一筆買進賣出後得到的利潤  
或者是上一輪賣出第一筆股票後的利潤，兩者取其大  
buy2: 在該價格買入第二筆股票後手裡剩的錢  
同等於上一輪賣出第一筆股票後的利潤減去當前股票價格  
sell2: 在該價格賣出第二筆股票後手裡剩的錢，即最後利潤  
或者是上一輪賣出第二筆股票後的利潤，兩者取其大  
我們能做的就是儘可能的低價買入後高價出售(廢話)  
要注意的是第二筆交易裡我們是把第一筆交易的利潤考慮進去的  
所以能達到題目要求  
此法時間複雜度為O(n)，空間複雜度為O(1)
  
***
  
### [00139.Word_Break](../../SourceCode/Python/Problem/00139.Word_Break.py) Level: Medium Tags: [DP, Backtracking]
  
Time:  O(n * j), worst case is O(n^2)  
Space: O(n)    
  
思路: 給你一個用任意字母片段的List  
要你判斷用這些片段是否能湊出輸入的英文片段  
例如
```python
s = "catsandog"
wordDict = ["cats", "dog", "sand", "and", "cat"]
```
s可被字典裡的字串拼出來，所以結果為True  

##第一個方法是  
從第一個字元開始依次向後尋找，直到找到一個可以分開的地方(斷句)，這時代表目前的substing在dictionary中    
如果找到最後都沒找到，傳回False  
  
找到第一個斷句後，接下來找下一個斷句處，就是從第一個斷句後的字元開始找連續的字串  
但此時和第一次尋找稍微不同，例如說 word = 'ab', dict= {'a', 'ab', ...}  
在從word裡找到a之後，接下來要處理的是b，我們發現b不再dict中  
但b可以和a相結合形成ab，而ab在dict中  
所以這裡的每個字串有三個選擇  

+ 自己單獨為個體到dict中尋找
+ 和前面的string合併起來一起找
+ 等後面的新字元，構成更長的substring  

以第二項來說，我們需要跟前面的string合併起來找，所以我們需要紀錄訊息來代表前面的substring  
是從哪裡分開而滿足條件的  
如此我們就能一次從離前一個substring近的部分進行結合  
例如 word = 'aab', dict= {'a', 'aab'}  
處理a時在dict中，處理下一個a也在dict中  
但再下一個b就不在dict中了  
此時就和前面的b結合形成 ab ，但發現也不在dict中  
於是繼續跟前面的substring結合形成aab，此時在dict中了  
於是word便滿足條件

## 第二個方法是  
在拼湊的過程中，我們會需要不斷檢查之前拼湊的結果
所以可以用Dynamic Programming解題  

首先我們先宣告一個長度比輸入字串多1的一維陣列  
除了第一個是True外，其他內容全為False，如:

|   | c | a | t | s | a | n | d | o | g |
|---|---|---|---|---|---|---|---|---|---|
| T |   |   |   |   |   |   |   |   |   |

接著我們從第一個字元c來開始掃描他們有沒有在預設的字典中  
c我們可以看到字典裡沒有這個字，所以是False
第二個字起比較複雜  
我們比較的順序會是這樣:   
ca=>a  
第三個字加入後會是:
cat=>at=>t
我們發現cat有符合字典中的字了  
所以在t的位置把False改成True  

|   | c | a | t | s | a | n | d | o | g |
|---|---|---|---|---|---|---|---|---|---|
| T |   |   | T |   |   |   |   |   |   |


第四個字母加入後會是:  
cats=>ats=>ts=>s  
和上面一樣，字典裡有cats這個字  
所以在s的位置改成True

|   | c | a | t | s | a | n | d | o | g |
|---|---|---|---|---|---|---|---|---|---|
| T |   |   | T | T |   |   |   |   |   |

第五個字母加入後是catsa  
catsa=>asta=>sta=>ta=>a  
沒什麼好說的
    
第六個字母加入後事catsan  
catsan=>astan=>tsan=>san=>an=>n  
在比到san的時候，因為san是在字典裡的字  
我們除了看san本身外，也要回頭去看扣掉san的字串比對的結果  
而扣掉san的字串是cat，之前的比對結果是True  
所以這裡我們也能填上True    

|   | c | a | t | s | a | n | d | o | g |
|---|---|---|---|---|---|---|---|---|---|
| T |   |   | T | T |   | T |   |   |   |
  
  
第七個字母加入後為 catsand，省略
第八個字母加入後為 catsando，省略
第九個字母加入後為 catsandog
catsandog=>atsandog=>tsandog=>sandog  
=>andog=>ndog=>dog=>og=>g  
在dog時，我們會去參考剩下的字串的比對結果，就是catsan
這在剛才的比對中已經證明為True了  
所以dog這裡也可以寫為True  

|   | c | a | t | s | a | n | d | o | g |
|---|---|---|---|---|---|---|---|---|---|
| T |   |   | T | T |   | T |   |   | T |

全部比完後我們看最後面的比對結果  
就是題目要的答案  
  
下圖是另一個用DP的範例  
![Alt text](Res/dp.png)
***
  
  
### [00140.Word_Break II](../SourceCode/Python/Problem/00140.Word_Break_II.py) Level: Hard Tags: [DP, Sequence DP, DFS]
  
  
***
  
### [00279.Perfect_Squares](../SourceCode/Python/Problem/00279.Perfect_Squares.py) Level: Medium Tags: [DP]
  
  
思路:這題雖然可以用數學定理的四平方和解題  
( Lagrange's four-square theorem，每個正整數均可表示為4個整數的平方和 )  
但我們在面試中不太可能碰到剛好能用數學定理解題的情況，還是考慮一般解吧。  
此題需要使用的是Dynamic Programming  
而且屬於重疊子問題 (自上而下 ): 每個子問題只解一次，把解保存在一個需要時就可以查看的表中  
每次查表的時間為常數  
  
首先把輸入的正整數所有的完全平方數都找出來並在dp紀錄上填上1  
它是我們之後dynamic programming的依據  
接著從1開始找每個整數(x)加另一個從1開始整數的平方(y)  
例如 x+y*y  
看他們的和是否小於等於n  
是的話就能加入我們的dp筆記     
如果沒寫過的話，就能直接從dp[x]加1(這個1是找到的y給的)  
如果寫過的話，就比較目前筆記裡寫過的值+1有沒有小於目前值  
比較小的話當然採用dp[x]+1  
如此走完整個迴圈，則dp[n]即為答案
  
  
  
***
  
### [00309.Best_Time_to_Buy_and_Sell_Stock_with_Cooldown](../../SourceCode/Python/Problem/00309.Best_Time_to_Buy_and_Sell_Stock_with_Cooldown.py) Level: Medium Tags: [DP]
  
Time:  O(n)  
Space: O(n)  
  
思路: 是[00122.Best_Time_to_Buy_and_Sell_Stock_II](../../SourceCode/Python/Problem/00122.Best_Time_to_Buy_and_Sell_Stock_II.py)   
     和[00121.Best_Time_to_Buy_and_Sell_Stock_II](../../SourceCode/Python/Problem/00121.Best_Time_to_Buy_and_Sell_Stock.py) 的延伸  
如果不熟動態規劃()Dynamic Programming)的話  
這題可以算是Hard了  
題目和之前幾題一樣都要求買低賣高，但多了冷卻期  
也就是賣出後的那一天不能買進股票  
如果你第一天買入，第二天賣出的話  
你得等第四天後才能買進第二筆  
  
這裡用動態規劃需要令兩個List  
分別是buy和sell，長度為prices長度  
buy[i]和sell[i]分別代表第i天持股股票的最大利潤  
和第i天賣出股票時的最大利潤  
這裡我們要寫出他們的狀態轉移方程  
對於buy[i]，最大利潤有兩種可能:  
1. 前一天的持股buy[i-1]，到今天仍未賣出  
2. 之前賣出股票後今天買了股票，花掉了prices[i]
因為有一天的冷卻期，所以是sell[i-2]-prices[i]  
第i天的買進最大利潤就為  
```python
buy[i] = max(buy[i-1], sell[i-2] - prices[i]
```
  
對於sell[i]，最大利潤有兩種可能:  
1. 前一天賣出後，今天仍然沒買進股票  
所以最大利潤是sell[i-1]  
2. 前一天買進後，今天賣出持股得到了今天股價prices[i]  
所以是buy[i-1] + prices[i]  
所以我們可以知道sell[i]的最大利潤為:  
```python
sell[i] = max(sell[i-1], buy[i-1] + prices[i])
```
  
不斷轉移狀態到最後一天賣出持股 (sell[len(prices)-1])  
就是我們所能達到的最大利潤了  
  
***
  
### [00329.Longest_Increasing_Path_in_a_Matrix](../../SourceCode/Python/Problem/00329.Longest_Increasing_Path_in_a_Matrix.py) Level: Hard Tags: [DFS, DP]
  
Time:  O(m * n)  
Space: O(m * n)  

思路:找出2D陣列裡所能排出最長的遞增序列  
這題非常的難，除了要會用DFS Traversal所有可能的元素外  
還要會運用Dynamic Programming  
不然就會敗在題目給的超大2D陣列下吐出Time Limit Exceeded  
  
首先我們先造出全部為0的2D陣列  
這陣列用來記錄曾經找出過的最長序列元素個數  
接著逐行逐列，用DFS找出每個元素所能形成的最長序列個數  
DFS相關的步驟可以寫成另一個函式  
這函式一開始就要先檢查dp陣列裡是否已經紀錄過找過的最長序列元素數  
找過的話就可以直接給遞回中呼叫的 sub function答案以節省時間  
沒有找過的話，我們定出四個方向的tuple  
分別代表目前元素的上下左右方  
然後依次去比較(上下左右)方的元素是否大於目前元素  
是的話深度就+1  
並且遞回呼叫DFS繼續往深處找  
該元素所能達到的最大深度找完後，把它紀錄在dp上  
就能在Leetcode給的時間限制內把所有元素所能到達的最大深度全部算完  
最後只要看dp陣列中的最大值  
就是題目要的答案了  
  
  
***  
  
### [00368.Largest_Divisible_Subset](../../SourceCode/Python/Problem/00368.Largest_Divisible_Subset.py) Level: Medium Tags: [DP]
    
  
思路: 給你一個不同整數組成的數列，要你產生另一個數列  
其中，這數列是原題的子集合，且裡面的數字任取兩個出來  
其中一個數必能整除另一個數  

這題算是DP的難題，我到現在還參不透  
只能翻譯別人的解答  

1. 分析架構    
按照題意我們可以注意到，如果兩個數a能整除b且b能整除c  
那麼a必定也能整除c  
為了計算方便，我們需要把數列做排序  
但是考慮到可能會有其他分支的情況  
例如[1,2,4,8,10,20,40,80]    
可以分成 [4,8] 或[10,20,40,80],  
所以我們要另外指派一個陣列來存放這個最長子集合的元素index  
  
2. 找出狀態轉移方程  
令dp為最長子集合的陣列，存放包含數字n的子集合長度  
則dp[i]表示到數字nums[i]位置最大可整除的子集合的長度  
假如j >= i 且nums[j] % nums[i] == 0  
代表比j更大的數能整除nums[j]的必也能整除nums[i]
所以dp[i] = dp[j] + 1
  
3. 建構DP  
以[1,2,3,4]為例  
首先建構一個一維DP，預設長度都為0  

|   | 1 | 2 | 3 | 4 |
|---|---|---|---|---|
|長度|   |   |   |   |

我們從最大的數開始掃起  
每次取 (4,4) => (3,3), (3,4) => (2,2),(2,3),(2,4)   
=>(1,1),(1,2),(1,3),(1,4)    
這樣的掃描順序  
  
取(4,4) 時，4必能整除自己，所以dp[4] = do[4] + 1  

|   | 1 | 2 | 3 | 4 |
|---|---|---|---|---|
|長度|   |   |   | 1 | 

取(3,3) 時，3必能整除自己，所以dp[3] = do[3] + 1 

|   | 1 | 2 | 3 | 4 |
|---|---|---|---|---|
|長度|   |   | 1 | 1 | 

取(3,4)時條件不成立，跳過  
取(2,2) 時，2必能整除自己，所以dp[2] = do[2] + 1  

|   | 1 | 2 | 3 | 4 |
|---|---|---|---|---|
|長度|   | 1 | 1 | 1 | 

取(2,3)時條件不成立，跳過   
取(2,4)時，4可整除2，所以d[2] = dp[4] + 1
把原本dp[2]的值蓋掉了  

|   | 1 | 2 | 3 | 4 |
|---|---|---|---|---|
|長度|   | 2| 1 | 1 | 

1可以整除以所有數字  
dp[1] = dp[1] + 1 => 1  
dp[1] = dp[2] + 1 => 3  
dp[1] = dp[3] + 1 => 2  
dp[1] = dp[4] + 1 => 2  
  
我們發現dp[2]的結果可帶來最大長度  
但照迴圈走法會被後面的狀態轉移方程蓋掉  
所以我們需要多一個判斷 dp[i] < dp[j] + 1: 
```python
if nums[j] % nums[i] == 0 and dp[i] < dp[j] + 1:
    dp[i] = dp[j] + 1
    child[i] = j
```
所以最後dp結果為  

|   | 1 | 2 | 3 | 4 |
|---|---|---|---|---|
|長度| 3 | 2| 1 | 1 | 
   
為了解決Step1裡多重分組的問題，我們需要多設一個陣列存放元素的index  
還需要用兩個變數max和max_index 
max存放最長dp的長度  
max_index存放這subset的起始index  
最後我們就能用一個for迴圈把答案的subset建構出來  
```python
for k in xrange(max):
    ans.append(nums[max_index])
    max_index = child[max_index]
```  
還是用剛才的例子，最後dp判斷全跑完時  
subset的陣列如下所示  

|index    | 0 | 1 | 2 | 3 |
|---      |---|---|---|---|
|max_index| 1 | 3| 2 | 3 | 
   
這表是告訴你  
如果我今天取第0個元素時，他的下一個能互相整除的元素在index 1  
繼續取index 1的元素時，他的下一個能互相整除的元素在 index 3 
max為2，所以取到第三個元素就停止了  
答案為[1,2,4]   
   
***  
