# -*- coding: UTF-8 -*-
'''
Give n = 3
return all permutation:
[1,2,3], [1,3,2], [2,1,3], [3,1,2], [3,2,1]
'''


'''
如果是1 2，將兩個旋轉就得到新組合2 1。
如果是 1 2 3，想到得2開頭的新組合，可以從1 2 3將2拿到前頭得到2 1 3，
想得到3開頭的新組合，可以將3拿到前頭，得到3開頭的3 1 2。

可以觀察到，從1 2 3得到2 1 3，其實就是將開頭的1 2旋轉，
從1 2 3得到3 1 2，就是將1 2 3旋轉。
如果這樣的旋轉可以得到新排列，
那麼對於1 2 3、2 1 3、3 1 2的尾數列2 3、1 3、1 2也作相同旋轉處理，
不就也可以得到尾數列的新排列。也就是：

1 2 3
1 3 2
2 1 3
2 3 1
3 1 2
3 2 1

以上紅色部份表示對整個數列作旋轉處理，底線表示對尾數列作旋轉處理，
也就是對尾數列進行相同動作，這在程式上就是遞迴處理。
因此對於任意長度的符號數列排列組合時，可對傳入數列作旋轉處理，
旋轉間隔一開始是0，逐步增加，對旋轉過後的每個數列之尾數列再作排列組合。
例如對於 1 2 3 4：
1 2 3 4 -> 旋轉 1 為 1，遞迴處理2 3 4
2 1 3 4 -> 旋轉 1 2 為 2 1，遞迴處理1 3 4
3 1 2 4 -> 旋轉 1 2 3 為 3 1 2，遞迴處理1 2 4
4 1 2 3 -> 旋轉 1 2 3 4 為 4 1 2 3，遞迴處理 1 2 3 


'''

'''
如果我們寫：

a=[0,1,2,3,4]

b=a

c=a[:]

則b跟a都指向同一個address，當a的內容改變，b的內容跟著變，
但c是指向另一個address，因此當a的內容改變，c還是等於[0,1,2,3,4]。

'''
def permutation(nums, index, ans):
    if index >= len(nums):
        ans.append(nums[:])
        return
    else:
        for i in xrange(index, len(nums)):
            nums[i], nums[index] = nums[index], nums[i]
            permutation(nums, index+1, ans)
            nums[index], nums[i] = nums[i], nums[index]

n = 3
nums = []
for i in xrange(n):
    nums.append(i+1)

ans = []

permutation(nums, 0, ans)
print ans



