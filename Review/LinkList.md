
https://wdxtub.com/interview/14520596803958.html

# 鏈表
鏈表(linked list)是一種常見的線性數據結構。  
對於單向鏈表(singly linked list)，每個節點有一個next指針指向後一個節點，  
還有一個成員變量用以存儲數值；對於雙向鏈表(doubly Linked List)，  
還有一個prev指針指向前一個節點。  
與數組類似，搜索鏈表需要O(n)的時間複雜度，  
但是鏈表不能通過常數時間(O(1))讀取第k個數據。  
鏈表的優勢在於能夠以較高的效率在任意位置插入或刪除一個節點。

## 解題策略
* 當涉及對頭節點的操作，我們不妨考慮創建啞節點。
* 由於題目涉及在鏈表中尋找特定位置，我們用兩個指針變量以不同的速度遍歷該鏈表。
* 循環遍歷鏈表, 每次只處理當前指針的next 變量，由此實現鏈表的逆轉。  

## 鏈表的基本操作
凡是修改單向鏈表的操作，只需考慮：

1. 哪個節點的next指針會受到影響，則需要修正該指針；
2. 如果待刪除節點是動態開辟的內存空間，則需要釋放這部分空間(C/C++)  

畢竟，一個鏈表節點，無非是包含value和next這兩個成員變量的數據結構而已。  
對於雙向鏈表，類似的，則只需額外考慮誰的prev指針會受到影響。  

舉例如下：

```
void delNode(ListNode *prev) {
  ListNode *curr = prev->next;
  // 刪除curr節點只會使prev節點的next受到影響
  prev->next = curr->next;    
  delete curr;    // 清理trash指針
}
```
註：操作鏈表時務必註意邊界條件：  
curr == head, curr == tail 或者 curr == NULL  

### 兩種存儲方式
* 順序存儲結構：隨機讀取，訪問時是 O(1)
* 鏈式存儲結構：插入和刪除 O(1)，訪問時最壞是 O(n)
### 分類（根據指針域）
* 單向鏈表
* 雙向鏈表
* 循環鏈表
## 反轉鏈表
* 訪問某個節點 curt.next 時，要檢驗 curt 是否為 null
* 要把反轉後的最後一個節點（即第一個節點）指向 null
## 刪除某個節點
* 由於需要知道前繼節點的信息，而前繼節點可能會導致表頭產生變化，所以需要一些技巧 Dummy Node
* 鏈表指針的可靠度
    * 訪問某個節點 curt.next 時，要檢驗 curt 是否為 null
    * 全部操作結束後，判斷是否有環；若有，則置其中一端為 null
## Dummy Node
* 是一個虛擬節點 dummy.next = head
* 針對單向鏈表沒有前向指針的問題，保證鏈表的 head 不會在刪除操作中丟失
* 也可以用來進行 head 節點（但比較少見）
* 當鏈表的 head 可能有變化時，使用 dummy node 可以簡化代碼，最後返回 dummy.next 即可
## 快慢指針
* 快慢指的是指針向前移動的步長，一般來說，快指針每次移動 2，慢指針每次移動 1
* 主要有兩個應用
    * 快速找出未知長度單鏈表的中間節點
        * 設置兩個指針 *fast 和 *slow 都指向頭節點
        * *fast 移動速度是 *slow 的兩倍
        * *fast 指向末尾節點時，*slow 正好就在中間
    * 判斷單鏈表是否有環
        * 設置兩個指針 *fast 和 *slow 都指向頭節點
        * *fast 移動速度是 *slow 的兩倍
        * 如果 *fast == null 說明該單鏈表不是循環鏈表
        * 如果 *fast == *slow 說明該鏈表是循環鏈表
* 其他應用
    * 找倒數第 N 個節點
        * 設置兩個指針 *fast 和 *slow 都指向頭節點
        * *fast 先移動 N 步，然後兩個指針一起前進
        * *fast 到達末尾時，*slow 即為倒數第 N 個節點
        
        